# コーディングルール

## 1. 基本原則

### Type First アプローチ
- 実装前に必ず型定義を行う
- 型の整合性を最優先で確認
- 型安全性を保証するための厳格な型チェック
```typescript
// 良い例：実装前の型定義
interface FeedResponse {
  content: string;
  timestamp: number;
}

// 悪い例：型定義なしの実装
const response = await fetch(url);
const data = await response.json();
```

### テスト駆動開発（TDD）
1. テスト作成：機能実装前にテストを書く
2. 失敗確認：テストが失敗することを確認
3. 実装：テストが通るように実装
4. リファクタリング：コードの改善
```typescript
// モジュールの疎結合を意識したテスト
interface FeedFetcher {
  fetch(url: string): Promise<string>;
}

// テスト
Deno.test("RSSフィードの取得", async () => {
  const mockFetcher: FeedFetcher = {
    fetch: (url: string) => Promise.resolve("<?xml...")
  };
  const result = await getFeed(mockFetcher, "https://example.com");
  assertEquals(result.status, 200);
});
```

### デバッグと問題解決
1. ログ戦略
```typescript
// 段階的なデバッグ情報
console.debug("入力値:", input);
console.debug("処理状態:", state);
console.debug("出力値:", output);
```

2. エラー特定プロセス
- エラーの再現手順の文書化
- 二分法によるエラー箇所の特定
- 修正計画の立案と実行

## 2. プロジェクト構造

```
/
├── routes/      # ルートハンドラー
├── tests/       # テストファイル
├── types/       # 型定義ファイル
└── scripts/     # ユーティリティスクリプト
```

## 3. 命名規則

### ファイル名
- 型定義: `{機能名}.types.ts`
- テスト: `{機能名}_test.ts`
- 実装: `{機能名}.ts`

### 変数・関数名
- インターフェース: `I` プレフィックスは使用しない
- 型: パスカルケース（例：`FeedResponse`）
- 変数・関数: キャメルケース（例：`getFeedContent`）

## 4. コード規約

### モジュール設計
```typescript
// 疎結合なモジュール設計
export interface FeedService {
  getFeed(url: string): Promise<FeedResponse>;
}

export class RSSFeedService implements FeedService {
  constructor(private fetcher: FeedFetcher) {}
  // 実装
}
```



### 非同期処理
- async/awaitを使用
- Promise chainingは避ける
- エラーハンドリングを必ず含める

## 5. セキュリティガイドライン

### 入力検証
```typescript
// 型による安全性の確保
function validateInput(input: unknown): asserts input is ValidInput {
  if (!isValidInput(input)) {
    throw new ValidationError("不正な入力");
  }
}
```

### アクセス制御
- 型安全な認証・認可の実装
- セキュリティ上の懸念事項は型で表現

## 6. キャッシュ戦略

### 型安全なキャッシュ操作
```typescript
interface CacheEntry<T> {
  value: T;
  timestamp: number;
  size?: number;  // データサイズの追跡
}

async function getCached<T>(key: string[]): Promise<CacheEntry<T> | null> {
  return await kv.get(key);
}
```

### キャッシュ管理
- データサイズの監視と制限
- 有効期限の設定と自動クリーンアップ
- メモリ使用量の最適化

## 7. テスト規約

### テストファイル構造
```typescript
// 準備
const testData: TestInput = {
  url: "https://example.com",
  expected: "<?xml..."
};

// テストケース
Deno.test("機能テスト", async (t) => {
  await t.step("正常系", async () => {
    // テスト実装
  });
  
  await t.step("異常系", async () => {
    // エラーケースのテスト
  });
});
```

### テストカバレッジ
- 型の境界値テスト
- エッジケースの網羅
- モック/スタブの適切な使用

### XMLパース関連テスト
- パーサーの選択と妥当性確認
- リンク書き換えの正確性検証
- 異常系XMLのハンドリング

## 8. デバッグ戦略

### ログレベル
- DEBUG: 詳細な処理情報
- INFO: 重要なイベント
- WARN: 警告
- ERROR: エラー情報

### 問題解決手順
1. エラーの再現と記録
2. ログによる問題箇所の特定
3. 二分法による原因の絞り込み
4. 修正計画の立案
5. テストによる修正の検証

## 9. タスク管理

### TODO管理
- TODOリストの定期的な更新
- 完了したタスクのマーク
- 未完了タスクの優先順位付け

### 実装優先順位
1. セキュリティ関連の実装
2. コア機能の実装
3. パフォーマンス最適化
4. 機能拡張

## 10. パフォーマンス最適化

- 型レベルでのパフォーマンス考慮
- 早期のパフォーマンステスト実施
- 型による最適化の保証
- KVストアのパフォーマンスモニタリング